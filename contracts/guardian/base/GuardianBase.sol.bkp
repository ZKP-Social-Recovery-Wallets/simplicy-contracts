// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import {IGuardian} from "../IGuardian.sol";
import {GuardianBaseInternal} from "./GuardianBaseInternal.sol";
import {GuardianBaseStorage} from "./GuardianBaseStorage.sol";

/**
 * @title Base Guardian implementation, excluding optional extensions
 */
abstract contract GuardianBase is IGuardian, GuardianBaseInternal {
    using GuardianBaseStorage for GuardianBaseStorage.Layout;

    /**
     * @notice adds an identity commitment to an existing group
     * @param groupId: Id of the group
     * @param identityCommitments: array of new identity commitments
     *
     * TODO: hash the identityCommitments to make sure users can't see
     *       which identityCommitment belongs to the guardian
     *
     */
    function addMembers(uint256 groupId, uint256[] memory identityCommitments)
        external
        override
        onlyGroupAdmin(groupId)
    {
        _beforeAddMembers(groupId, identityCommitments);

        for (uint256 i = 0; i < identityCommitments.length; i++) {
            _addMember(groupId, identityCommitments[i]);
        }

        _afterAddMembers(groupId, identityCommitments);
    }

    function updateGroupAdmin(uint256 groupId, address newAdmin)
        external
        override
        onlyGroupAdmin(groupId)
    {
        GuardianBaseStorage.layout().groupAdmins[groupId] = newAdmin;

        emit GroupAdminUpdated(groupId, _msgSender(), newAdmin);
    }

    /**
     * @notice removes an identity commitment from an existing group. A proof of membership is
     *         needed to check if the node to be deleted is part of the tree
     * @param groupId: Id of the group
     * @param identityCommitment: xxisting identity commitment to be deleted
     * @param proofSiblings: Array of the sibling nodes of the proof of membership
     * @param proofPathIndices: Path of the proof of membership
     *
     * TODO: hash the identityCommitment to make sure users can't see
     *       which identityCommitment belongs to the guardian
     *
     */
    function removeMember(
        uint256 groupId,
        uint256 identityCommitment,
        uint256[] calldata proofSiblings,
        uint8[] calldata proofPathIndices
    ) external override onlyGroupAdmin(groupId) {
        _beforeRemoveMember(
            groupId,
            identityCommitment,
            proofSiblings,
            proofPathIndices
        );

        _removeMember(
            groupId,
            identityCommitment,
            proofSiblings,
            proofPathIndices
        );

        _afterRemoveMember(
            groupId,
            identityCommitment,
            proofSiblings,
            proofPathIndices
        );
    }

    function verifyProof(
        uint256 groupId,
        bytes32 signal,
        uint256 nullifierHash,
        uint256 externalNullifier,
        uint256[8] calldata proof
    ) external override {
        _beforeVerifyProof(
            groupId,
            signal,
            nullifierHash,
            externalNullifier,
            proof
        );
        _verifyProof(groupId, signal, nullifierHash, externalNullifier, proof);

        _afterVerifyProof(
            groupId,
            signal,
            nullifierHash,
            externalNullifier,
            proof
        );
    }

    function getGroupAdmin(uint256 groupId) external view returns (address) {
        return _getGroupAdmin(groupId);
    }

    /**
     * @notice ceates a new group by initializing the associated tree
     * @param groupId: Id of the group
     * @param depth: Depth of the tree
     * @param zeroValue: Zero value of the tree
     */
    function createGroup(
        uint256 groupId,
        uint8 depth,
        uint256 zeroValue,
        address admin
    ) public override onlySupportedDepth(depth) {
        _beforeCreateGroup(groupId, depth, zeroValue);

        _createGroup(groupId, depth, zeroValue);

        GuardianBaseStorage.layout().groupAdmins[groupId] = admin;

        emit GroupAdminUpdated(groupId, address(0), admin);

        _afterCreateGroup(groupId, depth, zeroValue);
    }
}
